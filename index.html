import React, { useState, useEffect, useRef, useCallback, useMemo } from 'react';

// --- Global API Configuration ---
const LLM_MODEL = 'gemini-2.5-flash-preview-09-2025';
const TTS_MODEL = 'gemini-2.5-flash-preview-tts';
const apiKey = ""; // API key is provided by the runtime environment

const API_URL = (model, key) =>
    `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${key}`;


// Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø£ØµÙˆØ§Øª Ø§Ù„Ù…ØªØ§Ø­Ø©
const ALL_VOICES = [
    // Ø£ØµÙˆØ§Øª Ø°ÙƒÙˆØ±ÙŠØ© (Male Voices)
    { name: "Achird", label: "Achird (Ù‚ÙˆÙŠ ÙˆØ¹Ù…ÙŠÙ‚)", gender: "Male" },
    { name: "Charon", label: "Charon (Ø¥Ø®Ø¨Ø§Ø±ÙŠ ÙˆÙ…Ø­ØªØ±Ù)", gender: "Male" },
    { name: "Iapetus", label: "Iapetus (ÙˆØ§Ø¶Ø­ ÙˆÙ…Ø¹Ø¨Ø±)", gender: "Male" },
    { name: "Kore", label: "Kore (Ù‚ÙˆÙŠ ÙˆÙˆØ§Ø«Ù‚)", gender: "Male" },
    { name: "Orus", label: "Orus (Ø­Ø§Ø²Ù… ÙˆÙ…Ø­ØªØ±Ù)", gender: "Male" },
    { name: "Fenrir", label: "Fenrir (Ù…ØªØ­Ù…Ø³ ÙˆØ¯ÙŠÙ†Ø§Ù…ÙŠÙƒÙŠ)", gender: "Male" },
    { name: "Umbriel", label: "Umbriel (Ø¯Ø§ÙØ¦ ÙˆÙˆØ¯ÙˆØ¯)", gender: "Male" },
    { name: "Sadachbia", label: "Sadachbia (Ø¹Ù…ÙŠÙ‚ ÙˆÙ…Ù…ÙŠØ²)", gender: "Male" },

    // Ø£ØµÙˆØ§Øª Ø£Ù†Ø«ÙˆÙŠØ© (Female Voices)
    { name: "Despina", label: "Despina (Ù†Ø§Ø¹Ù… ÙˆÙˆØ¯ÙˆØ¯)", gender: "Female" },
    { name: "Aoede", label: "Aoede (Ù…Ù†Ø¹Ø´ ÙˆÙˆØ§Ø¶Ø­)", gender: "Female" },
    { name: "Leda", label: "Leda (Ø´Ø§Ø¨ ÙˆØ¯Ø§ÙØ¦)", gender: "Female" },
    { name: "Callirrhoe", label: "Callirrhoe (Ù‡Ø§Ø¯Ø¦ ÙˆØ°ÙƒÙŠ)", gender: "Female" },
    { name: "Zephyr", label: "Zephyr (Ù…Ø´Ø±Ù‚ ÙˆÙ…Ø¹Ø¨Ø±)", gender: "Female" },
    { name: "Achernar", label: "Achernar (Ø£Ù†ÙŠÙ‚ ÙˆØ§Ø­ØªØ±Ø§ÙÙŠ)", gender: "Female" },
];

// Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ø£ÙˆÙ„ÙŠ ÙˆØ§Ù„Ø£Ø³Ø§Ø³ÙŠ Ù„Ù„Ù…ØªØ­Ø¯Ø«ÙŠÙ†
const CORE_SPEAKERS = [
    { name: "Joe", voiceName: "Achird" }, // Ø§Ù„Ù…ØªØ­Ø¯Ø« 1
    { name: "Jane", voiceName: "Despina" }, // Ø§Ù„Ù…ØªØ­Ø¯Ø« 2
];

// --- Utility Functions ---

/**
 * ÙŠÙ†Ø¸Ù Ù†Ø§ØªØ¬ LLM Ù…Ù† Ø£ÙŠ ÙƒØªÙ„ ÙƒÙˆØ¯ (```) Ø£Ùˆ Ù…Ù‚Ø¯Ù…Ø§Øª ØºÙŠØ± Ø¶Ø±ÙˆØ±ÙŠØ©.
 * @param {string} text - Ø§Ù„Ù†Øµ Ø§Ù„Ø®Ø§Ù… Ù…Ù† LLM.
 * @returns {string} Ø§Ù„Ù†Øµ Ø§Ù„Ù†Ø¸ÙŠÙ.
 */
const cleanLLMOutput = (text) => {
    if (!text) return "";
    let cleaned = text.trim().replace(/^```[a-zA-Z]*\s*\n|```$/gs, '').trim();
    const unnecessaryPrefixes = [
        /^\s*Ø¥Ù„ÙŠÙƒ Ø§Ù„Ø­ÙˆØ§Ø±:\s*/i, /^\s*Ø¥Ù„ÙŠÙƒ Ø§Ù„Ø­ÙˆØ§Ø± Ø§Ù„Ø®Ø§Ù…:\s*/i, /^\s*Ø§Ù„Ø­ÙˆØ§Ø± Ø§Ù„Ù…ÙØ­Ø³ÙÙ‘Ù†:\s*/i,
        /^\s*Ø¥Ù„ÙŠÙƒ Ø§Ù„Ù†Øµ Ø§Ù„Ù…ÙØ­Ø³ÙÙ‘Ù†:\s*/i, /^\s*Ø¥Ù„ÙŠÙƒ Ø§Ù„Ù†Øµ Ø¨ØµÙŠØºØ© SSML:\s*/i,
    ];
    for (const prefix of unnecessaryPrefixes) {
        cleaned = cleaned.replace(prefix, '').trim();
    }
    return cleaned;
};

/**
 * Ø¯Ø§Ù„Ø© Ù…Ø³Ø§Ø¹Ø¯Ø© Ù„Ø¬Ù„Ø¨ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ø¹ Ø¢Ù„ÙŠØ© Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© (Exponential Backoff).
 */
const fetchWithBackoff = async (url, payload, maxRetries = 3) => {
    for (let currentRetry = 0; currentRetry < maxRetries; currentRetry++) {
        try {
            const response = await fetch(url, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });
            if (response.ok) return response;
            
            let errorBody = {};
            try { 
                // Attempt to parse JSON error body
                errorBody = await response.json(); 
            } catch (e) { 
                // Fallback for non-JSON errors
                errorBody = { error: { message: response.statusText || `HTTP Status ${response.status}.` } }; 
            }
            
            const errorMsg = errorBody.error?.message || 'Unknown Server Error';
            throw new Error(`Server Error: ${response.status} - ${errorMsg}`);
        } catch (error) {
            // Do not retry on Auth errors (401, 403, 400)
            if (currentRetry === maxRetries - 1 || error.message.includes('401') || error.message.includes('403') || error.message.includes('400')) {
                throw error;
            }
            // Exponential backoff delay
            const delay = Math.pow(2, currentRetry) * 1000 + (Math.random() * 500);
            await new Promise(resolve => setTimeout(resolve, delay));
            // Log retry silently
        }
    }
    // Should be unreachable if maxRetries > 0, but added for safety
    throw new Error('Maximum retry attempts reached.');
};

// Audio Conversion utilities 
const base64ToArrayBuffer = (base64) => {
    const binaryString = atob(base64);
    const len = binaryString.length;
    const bytes = new Uint8Array(len);
    for (let i = 0; i < len; i++) {
        bytes[i] = binaryString.charCodeAt(i);
    }
    return bytes.buffer;
};

const pcmToWav = (pcm16Data, sampleRate) => {
    const numChannels = 1;
    const bitDepth = 16;
    const numSamples = pcm16Data.length;
    const dataSize = numSamples * numChannels * (bitDepth / 8);
    const buffer = new ArrayBuffer(44 + dataSize);
    const view = new DataView(buffer);
    let offset = 0;

    const writeString = (view, offset, string) => {
        for (let i = 0; i < string.length; i++) { view.setUint8(offset + i, string.charCodeAt(i)); }
    };
    const writeUint32 = (view, offset, value) => { view.setUint32(offset, value, true); };
    const writeUint16 = (view, offset, value) => { view.setUint16(offset, value, true); };

    // RIFF chunk descriptor
    writeString(view, offset, 'RIFF'); offset += 4; 
    writeUint32(view, offset, 36 + dataSize); offset += 4; 
    writeString(view, offset, 'WAVE'); offset += 4; 

    // fmt sub-chunk
    writeString(view, offset, 'fmt '); offset += 4; 
    writeUint32(view, offset, 16); offset += 4; 
    writeUint16(view, offset, 1); offset += 2;
    writeUint16(view, offset, numChannels); offset += 2; 
    writeUint32(view, offset, sampleRate); offset += 4; 
    writeUint32(view, offset, sampleRate * numChannels * (bitDepth / 8)); offset += 4;
    writeUint16(view, offset, numChannels * (bitDepth / 8)); offset += 2; 
    writeUint16(view, offset, bitDepth); offset += 2; 

    // data sub-chunk
    writeString(view, offset, 'data'); offset += 4; 
    writeUint32(view, offset, dataSize); offset += 4; 

    const pcmOffset = 44;
    for (let i = 0; i < numSamples; i++) {
        // PCM data is signed 16-bit
        view.setInt16(pcmOffset + i * 2, pcm16Data[i], true);
    }

    return new Blob([buffer], { type: 'audio/wav' });
};


// --- React Component ---

export const App = () => {
    const [speakerCount, setSpeakerCount] = useState(2); 
    const [speakers, setSpeakers] = useState(CORE_SPEAKERS); 
    
    const [dialogue, setDialogue] = useState(`Joe: <prosody pitch="medium" rate="1.0x" volume="+2dB">Ù…Ø±Ø­Ø¨Ø§Ù‹ Ø¬ÙŠÙ†ØŒ <break time="500ms"/> Ù‡Ù„ Ø£Ù†Øª Ù…Ø³ØªØ¹Ø¯Ø© Ù„Ù…Ù†Ø§Ù‚Ø´Ø© Ø§Ù„ØªÙ‚Ø±ÙŠØ± Ø§Ù„Ø¬Ø¯ÙŠØ¯ØŸ</prosody>\nJane: <prosody pitch="medium" rate="1.0x" volume="+2dB">Ø¨Ø§Ù„ØªØ£ÙƒÙŠØ¯ Ø¬ÙˆØŒ Ù„Ù†Ø¨Ø¯Ø£ Ø¨ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø£Ø±Ù‚Ø§Ù….</prosody>`);
    const [rawDialogueInput, setRawDialogueInput] = useState(`Joe: Ù…Ø±Ø­Ø¨Ø§Ù‹ Ø¬ÙŠÙ†ØŒ Ù‡Ù„ Ø£Ù†Øª Ù…Ø³ØªØ¹Ø¯Ø© Ù„Ù…Ù†Ø§Ù‚Ø´Ø© Ø§Ù„ØªÙ‚Ø±ÙŠØ± Ø§Ù„Ø¬Ø¯ÙŠØ¯ØŸ\nJane: Ø¨Ø§Ù„ØªØ£ÙƒÙŠØ¯ Ø¬ÙˆØŒ Ù„Ù†Ø¨Ø¯Ø£ Ø¨ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø£Ø±Ù‚Ø§Ù….`);
    const [loading, setLoading] = useState(false);
    const [audioUrl, setAudioUrl] = useState(null);
    const [errorMessage, setErrorMessage] = useState(null);
    const [globalVolume, setGlobalVolume] = useState(0); 
    const [globalRate, setGlobalRate] = useState(1.0);
    const [currentMode, setCurrentMode] = useState('convert');
    const [autoGenerateTopic, setAutoGenerateTopic] = useState('Ø­ÙˆØ§Ø± ØªØ¹Ù„ÙŠÙ…ÙŠ Ø¹Ù† ÙÙˆØ§Ø¦Ø¯ Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ ÙÙŠ Ù…Ø¬Ø§Ù„ Ø§Ù„ØªØ¹Ù„ÙŠÙ….');
    const [ssmlInstructions, setSSMLInstructions] = useState('Ø·Ø¨Ù‘Ù‚ Ù†Ø¨Ø±Ø© "Ù‚ÙˆÙŠØ© ÙˆØ¬Ø°Ø§Ø¨Ø©" Ø¹Ù„Ù‰ Joe ÙˆÙ†Ø¨Ø±Ø© "Ù„Ø·ÙŠÙØ© ÙˆÙ…Ø¹Ø¨Ø±Ø©" Ø¹Ù„Ù‰ Jane. Ø£Ø¶Ù ÙØªØ±Ø§Øª ØªÙˆÙ‚Ù Ø·Ø¨ÙŠØ¹ÙŠØ© ÙˆØ§Ø³ØªØ®Ø¯Ù… Ù†ØºÙ…Ø© Ø­ÙˆØ§Ø±ÙŠØ©.');
    const audioRef = useRef(null);

    // DIsplay Message Callback
    const displayMessage = useCallback((message, isError = false) => {
        setErrorMessage({ message, isError });
        setTimeout(() => setErrorMessage(null), 8000);
    }, []);

    // 1. Effect to manage speakers state based on speakerCount change
    useEffect(() => {
        // Ensure speakers array is initialized up to CORE_SPEAKERS size for safety
        const safeSpeakers = [...speakers];
        while (safeSpeakers.length < CORE_SPEAKERS.length) {
            safeSpeakers.push(CORE_SPEAKERS[safeSpeakers.length]);
        }
        
        if (speakerCount === 1) {
            // Keep only the first speaker and their current configuration
            setSpeakers(prev => [prev[0]]);
            
            // Attempt to simplify dialogue for one speaker
            const singleSpeakerName = CORE_SPEAKERS[0].name;
            const otherSpeakerName = CORE_SPEAKERS[1].name;

            if (rawDialogueInput.includes(otherSpeakerName + ':') || dialogue.includes(otherSpeakerName + ':')) {
                // Filter out lines from the second speaker
                const simplifiedRaw = rawDialogueInput.split('\n')
                    .filter(line => !line.startsWith(otherSpeakerName + ':') && line.trim() !== '')
                    .map(line => line.startsWith(singleSpeakerName + ':') ? line : `${singleSpeakerName}: ${line.replace(/^\w+:\s*/, '')}`)
                    .join('\n') || `${singleSpeakerName}: Ù…Ø±Ø­Ø¨Ø§ØŒ Ø£Ù†Ø§ Ø§Ù„Ù…ØªØ­Ø¯Ø« Ø§Ù„ÙˆØ­ÙŠØ¯ Ù‡Ù†Ø§.`;

                const simplifiedSSML = dialogue.split('\n')
                    .filter(line => !line.startsWith(otherSpeakerName + ':') && line.trim() !== '')
                    .map(line => line.startsWith(singleSpeakerName + ':') ? line : `${singleSpeakerName}: ${line.replace(/^\w+:\s*/, '')}`)
                    .join('\n') || `${singleSpeakerName}: <prosody pitch="medium" rate="1.0x" volume="+2dB">Ù…Ø±Ø­Ø¨Ø§ØŒ Ø£Ù†Ø§ Ø§Ù„Ù…ØªØ­Ø¯Ø« Ø§Ù„ÙˆØ­ÙŠØ¯ Ù‡Ù†Ø§.</prosody>`;

                setRawDialogueInput(simplifiedRaw);
                setDialogue(simplifiedSSML);
                displayMessage('âš ï¸ ØªÙ… Ø§Ù„ØªØ¨Ø¯ÙŠÙ„ Ø¥Ù„Ù‰ Ù…ØªØ­Ø¯Ø« ÙˆØ§Ø­Ø¯. ØªÙ… ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ø­ÙˆØ§Ø±Ø§Øª ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹ Ù„ØªÙ†Ø§Ø³Ø¨ Ø§Ù„Ù…ØªØ­Ø¯Ø« Ø§Ù„Ø£ÙˆÙ„ ÙÙ‚Ø·.', true);
            }

        } else if (speakerCount === 2) {
            // Restore both speakers, ensuring custom changes are kept if possible
            setSpeakers(CORE_SPEAKERS.map((coreSpeaker, index) => {
                const existing = safeSpeakers[index];
                return existing ? existing : coreSpeaker;
            }));
        }
    // Corrected Dependencies
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [speakerCount, displayMessage, dialogue, rawDialogueInput]); 
    
    // --- Cleanup Effect for Audio URL ---
    useEffect(() => {
        const oldUrl = audioRef.current?.src;
        return () => {
            if (oldUrl && oldUrl.startsWith('blob:')) {
                URL.revokeObjectURL(oldUrl);
            }
        };
    }, [audioUrl]);


    const speakerNames = useMemo(() => speakers.slice(0, speakerCount).map(s => s.name).join(', '), [speakers, speakerCount]);

    // --- Speaker Management ---

    const handleSpeakerChange = (index, field, value) => {
        setSpeakers(prevSpeakers => {
            const newSpeakers = [...prevSpeakers];
            // Ensure the array has enough space if index is at the current limit
            if (!newSpeakers[index]) {
                 newSpeakers[index] = CORE_SPEAKERS[index] || { name: `Speaker ${index + 1}`, voiceName: ALL_VOICES[0].name };
            }

            // Only update if the index is valid for the current count
            if (index < speakerCount) {
                newSpeakers[index] = { ...newSpeakers[index], [field]: value };
            }
            return newSpeakers;
        });
    };

    // --- LLM Generation Functions ---

    // Function to generate raw dialogue based on a topic
    const generateDialogueFromTopic = async () => {
        if (!autoGenerateTopic.trim()) {
            displayMessage('ÙŠØ±Ø¬Ù‰ ÙƒØªØ§Ø¨Ø© Ù…ÙˆØ¶ÙˆØ¹ Ù„ØªÙˆÙ„ÙŠØ¯ Ø§Ù„Ø­ÙˆØ§Ø±.', true);
            return;
        }
        setLoading(true);
        setErrorMessage(null);

        const activeSpeakers = speakers.slice(0, speakerCount);
        const speakerList = activeSpeakers.map(s => s.name).join(' Ùˆ ');
        
        const dialogueFormat = `ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ† Ø§Ù„Ù†Ø§ØªØ¬ Ù†ØµÙ‹Ø§ Ø®Ø§Ù…Ù‹Ø§ Ø¨Ø§Ù„Ù„ØºØ© Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©ØŒ Ù…Ù†Ø³Ù‚Ù‹Ø§ Ø­ØµØ±ÙŠÙ‹Ø§ Ø¹Ù„Ù‰ Ø´ÙƒÙ„ 'SpeakerName: Dialogue' Ù„ÙƒÙ„ Ø³Ø·Ø± Ø¬Ø¯ÙŠØ¯.`;

        const systemPrompt = `Ø£Ù†Øª Ø®Ø¨ÙŠØ± ÙÙŠ ÙƒØªØ§Ø¨Ø© Ø§Ù„Ù†ØµÙˆØµ ÙˆØ§Ù„Ø­ÙˆØ§Ø±Ø§Øª. Ù…Ù‡Ù…ØªÙƒ Ù‡ÙŠ ÙƒØªØ§Ø¨Ø© Ø­ÙˆØ§Ø±/Ù†Øµ Ø¨Ø§Ù„Ù„ØºØ© Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© Ø§Ù„ÙØµØ­Ù‰ (Ø£Ùˆ Ù„Ù‡Ø¬Ø© Ù…Ø­Ø§ÙŠØ¯Ø©) Ø­ÙˆÙ„ Ø§Ù„Ù…ÙˆØ¶ÙˆØ¹: "${autoGenerateTopic}". Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ù…ØªØ­Ø¯Ø«ÙŠÙ† Ø§Ù„ØªØ§Ù„ÙŠÙŠÙ†: ${speakerList}. ${dialogueFormat} Ù„Ø§ ØªØ¶Ù Ø£ÙŠ ÙˆØ³ÙˆÙ… SSMLØŒ ÙˆÙ„Ø§ Ø£Ø±Ù‚Ø§Ù…ØŒ ÙˆÙ„Ø§ Ù…Ù‚Ø¯Ù…Ø§ØªØŒ ÙˆÙ„Ø§ Ø®Ø§ØªÙ…Ø§Øª. Ø§Ø¬Ø¹Ù„ Ø§Ù„Ø­ÙˆØ§Ø±/Ø§Ù„Ù†Øµ Ù…Ù† 6 Ø¥Ù„Ù‰ 8 Ø¬Ù…Ù„.`;
        
        const payload = {
            contents: [{ parts: [{ text: "Ù‚Ù… Ø¨ØªÙˆÙ„ÙŠØ¯ Ø§Ù„Ø­ÙˆØ§Ø± Ø§Ù„Ø¢Ù†." }] }],
            systemInstruction: { parts: [{ text: systemPrompt }] },
            model: LLM_MODEL 
        };

        try {
            const response = await fetchWithBackoff(API_URL(LLM_MODEL, apiKey), payload, 3);
            const result = await response.json();
            const text = result.candidates?.[0]?.content?.parts?.[0]?.text;

            if (text) {
                const cleanedText = cleanLLMOutput(text);

                // Basic validation for structure (expecting at least one colon for speaker format)
                if (cleanedText.length < 20 || !cleanedText.includes(':')) {
                     throw new Error('LLM returned an invalid dialogue format, expected speaker names followed by a colon.');
                }
                
                // Ensure text starts with an active speaker name, or prepend if missing (mostly for 1 speaker mode, though LLM should prepend)
                const startsWithActiveSpeaker = activeSpeakers.some(s => 
                    cleanedText.split('\n')[0]?.startsWith(s.name + ':')
                );

                let finalRaw = cleanedText;
                if (speakerCount === 1 && !startsWithActiveSpeaker) {
                    // Prepend the single speaker's name if the model was too raw
                    finalRaw = `${activeSpeakers[0].name}: ${cleanedText.replace(/^\s*/, '')}`;
                }

                setRawDialogueInput(finalRaw);
                displayMessage('âœ… ØªÙ… ØªÙˆÙ„ÙŠØ¯ Ø§Ù„Ø­ÙˆØ§Ø± Ø§Ù„Ø®Ø§Ù… Ø¨Ù†Ø¬Ø§Ø­. ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ù„Ø¢Ù† ØªØ­ÙˆÙŠÙ„Ù‡ Ø¥Ù„Ù‰ SSML.', false);
            } else {
                throw new Error('LLM did not return text or response structure was invalid.');
            }
        } catch (error) {
            console.error("Generation Error:", error);
            const msg = error.message.includes('400') ? 
                'âŒ Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø·Ù„Ø¨: ØªØ£ÙƒØ¯ Ù…Ù† Ø£Ù† Ù…ÙˆØ¶ÙˆØ¹ Ø§Ù„Ø­ÙˆØ§Ø± ÙˆØ§Ø¶Ø­ ÙˆÙ…Ù†Ø§Ø³Ø¨.' : 
                `âŒ ÙØ´Ù„ ØªÙˆÙ„ÙŠØ¯ Ø§Ù„Ø­ÙˆØ§Ø±. Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ø®Ø·Ø£: ${error.message}`;
            displayMessage(msg, true);
        } finally {
            setLoading(false);
        }
    };

    // Function to convert raw dialogue to SSML based on instructions
    const convertToSSML = async () => {
        if (!rawDialogueInput.trim()) {
            displayMessage('ÙŠØ±Ø¬Ù‰ ÙƒØªØ§Ø¨Ø© Ø§Ù„Ù†Øµ Ø§Ù„Ø®Ø§Ù… ÙÙŠ Ù…Ø±Ø¨Ø¹ Ø§Ù„Ø¥Ø¯Ø®Ø§Ù„ Ø£ÙˆÙ„Ø§Ù‹.', true);
            return;
        }
        setLoading(true);
        setErrorMessage(null);

        const systemPrompt = `Ø£Ù†Øª Ø®Ø¨ÙŠØ± ÙÙŠ ØªÙ†Ø³ÙŠÙ‚ Ù†ØµÙˆØµ SSML Ù„Ù„ØªØ±ÙƒÙŠØ¨ Ø§Ù„ØµÙˆØªÙŠ (TTS). Ù…Ù‡Ù…ØªÙƒ Ù‡ÙŠ Ø£Ø®Ø° Ø§Ù„Ø­ÙˆØ§Ø± Ø§Ù„Ù†ØµÙŠ Ø§Ù„Ø®Ø§Ù… ÙˆØªØ·Ø¨ÙŠÙ‚ ÙˆØ³ÙˆÙ… SSML Ø§Ù„Ø¯ÙŠÙ†Ø§Ù…ÙŠÙƒÙŠØ© (<prosody pitch/rate/volume/break>) Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø§Ù„ØªØ¹Ù„ÙŠÙ…Ø§Øª Ø§Ù„Ù…Ø®ØµØµØ©: "${ssmlInstructions}". Ø±ÙƒÙ‘Ø² Ø¹Ù„Ù‰ Ø§Ø³ØªØ®Ø¯Ø§Ù… ÙˆØ³ÙˆÙ… <break time="Xms"/> ÙÙŠ ÙÙˆØ§ØµÙ„ Ø§Ù„Ø¬Ù…Ù„ Ø§Ù„Ø·Ø¨ÙŠØ¹ÙŠØ© ÙˆÙ…ÙˆØ§Ø¶Ø¹ Ø§Ù„ØªÙˆÙ‚Ù Ù„Ø¥Ø¶Ø§ÙØ© Ø¥ÙŠÙ‚Ø§Ø¹ Ø´Ø¨ÙŠÙ‡ Ø¨Ø§Ù„Ù†Ø·Ù‚ Ø§Ù„Ø¨Ø´Ø±ÙŠØŒ ÙˆÙ‚Ù… Ø¨ØªØ¹Ø¯ÙŠÙ„ Ø·Ø¨Ù‚Ø© Ø§Ù„ØµÙˆØª (pitch) Ø£Ùˆ Ù…Ø¹Ø¯Ù„ Ø§Ù„Ù‚Ø±Ø§Ø¡Ø© (rate) Ø¨Ø´ÙƒÙ„ Ø·ÙÙŠÙ Ù„Ù…Ø­Ø§ÙƒØ§Ø© Ø§Ù„Ø£Ø¯Ø§Ø¡ Ø§Ù„ØµÙˆØªÙŠ Ø§Ù„Ù…Ø·Ù„ÙˆØ¨. ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ† Ø§Ù„Ù†Ø§ØªØ¬ Ù†ØµÙ‹Ø§ Ø®Ø§Ù…Ù‹Ø§ Ø¨Ø§Ù„Ù„ØºØ© Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©ØŒ Ù…Ù†Ø³Ù‚Ù‹Ø§ Ø­ØµØ±ÙŠÙ‹Ø§ Ø¹Ù„Ù‰ Ø´ÙƒÙ„ 'SpeakerName: <SSML> Dialogue </SSML>'ØŒ Ù…Ø¹ Ø§Ù„Ø­Ø±Øµ Ø¹Ù„Ù‰ Ø¹Ø¯Ù… ÙÙ‚Ø¯Ø§Ù† Ø§Ø³Ù… Ø§Ù„Ù…ØªØ­Ø¯Ø« (SpeakerName). Ù„Ø§ ØªØ¶Ù Ø£ÙŠ Ù†Øµ ØªÙØ³ÙŠØ±ÙŠ Ø£Ùˆ Ù…Ù‚Ø¯Ù…Ø§Øª Ø£Ùˆ Ø®Ø§ØªÙ…Ø§Øª. Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ù…ØªØ­Ø¯Ø«ÙŠÙ† Ø§Ù„Ù…Ø­Ø¯Ø¯ÙŠÙ†: ${speakerNames}.
        Ø§Ù„Ø­ÙˆØ§Ø± Ø§Ù„Ø®Ø§Ù…: ${rawDialogueInput}`;

        const payload = {
            contents: [{ parts: [{ text: "Ù‚Ù… Ø¨ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„ØªØ¹Ù„ÙŠÙ…Ø§Øª Ø¹Ù„Ù‰ Ø§Ù„Ø­ÙˆØ§Ø± ÙˆØªÙ‚Ø¯ÙŠÙ… Ø§Ù„Ù†Øµ Ø§Ù„Ù…ÙØ­Ø³Ù‘Ù† ÙÙ‚Ø·." }] }],
            systemInstruction: { parts: [{ text: systemPrompt }] },
            model: LLM_MODEL 
        };

        try {
            const response = await fetchWithBackoff(API_URL(LLM_MODEL, apiKey), payload, 3);
            const result = await response.json();
            const text = result.candidates?.[0]?.content?.parts?.[0]?.text;

            if (text) {
                const cleanedText = cleanLLMOutput(text);

                if (!cleanedText.includes('<prosody') || !cleanedText.includes(':')) {
                    // Fallback to simple SSML if LLM fails to add advanced tags
                    let simpleSSML = rawDialogueInput.split('\n')
                        .map(line => line.trim())
                        .filter(line => line.length > 0)
                        .map(line => {
                            const parts = line.split(':');
                            if (parts.length >= 2) {
                                const speaker = parts[0].trim();
                                const dialogueText = parts.slice(1).join(':').trim();
                                // Only add SSML if speaker is one of the active speakers
                                if (speakers.slice(0, speakerCount).some(s => s.name === speaker)) {
                                     return `${speaker}: <prosody pitch="medium" rate="1.0x" volume="+0dB">${dialogueText}</prosody>`;
                                }
                            }
                            return '';
                        }).filter(line => line.includes('<prosody')).join('\n');

                    if (simpleSSML.length > 0) {
                        setDialogue(simpleSSML);
                        displayMessage('âš ï¸ ÙØ´Ù„ LLM ÙÙŠ Ø¥Ø¶Ø§ÙØ© SSML Ù…ØªÙ‚Ø¯Ù…Ø©. ØªÙ… Ø¥Ø¶Ø§ÙØ© ØªÙ†Ø³ÙŠÙ‚ SSML Ø£Ø³Ø§Ø³ÙŠ. Ù‚Ù… Ø¨Ù…Ø±Ø§Ø¬Ø¹Ø© Ø§Ù„ØªØ¹Ù„ÙŠÙ…Ø§Øª.', true);
                    } else {
                         throw new Error('LLM failed to apply SSML tags or basic SSML structure is invalid. Please check the raw text format (Speaker: Dialogue) and ensure speaker names are correct.');
                    }
                } else {
                    setDialogue(cleanedText);
                    displayMessage('âœ… ØªÙ… ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ù†Øµ Ø§Ù„Ø®Ø§Ù… ÙˆØªØ·Ø¨ÙŠÙ‚ ÙˆØ³ÙˆÙ… SSML Ø¨Ù†Ø¬Ø§Ø­. Ø§Ù„Ù†Øµ Ø¬Ø§Ù‡Ø² Ù„Ù„ØªÙˆÙ„ÙŠØ¯ Ø§Ù„ØµÙˆØªÙŠ.', false);
                }

            } else {
                throw new Error('LLM did not return text or response structure was invalid.');
            }

        } catch (error) {
            console.error("SSML Conversion Error:", error);
            const msg = error.message.includes('400') ? 
                'âŒ Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø·Ù„Ø¨: ØªØ£ÙƒØ¯ Ù…Ù† Ø£Ù† Ø§Ù„ØªØ¹Ù„ÙŠÙ…Ø§Øª ÙˆØ§Ø¶Ø­Ø© ÙˆØµÙŠØºØ© Ø§Ù„Ø­ÙˆØ§Ø± Ø§Ù„Ø®Ø§Ù… ØµØ­ÙŠØ­Ø©.' : 
                `âŒ ÙØ´Ù„ ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ù†Øµ Ø¥Ù„Ù‰ SSML. Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ø®Ø·Ø£: ${error.message}`;
            displayMessage(msg, true);
        } finally {
            setLoading(false);
        }
    };

    // --- Core TTS Generation Function ---
    const generateMultiSpeakerAudio = async () => {
        setLoading(true);
        setErrorMessage(null);

        // Get active speakers
        const activeSpeakers = speakers.slice(0, speakerCount);

        // Validation: Check if all active speakers are represented in the dialogue
        const requiredDialogueFormat = activeSpeakers.every(s => dialogue.includes(`${s.name}:`));
        if (!dialogue.trim() || !requiredDialogueFormat) {
            displayMessage(`ÙŠØ±Ø¬Ù‰ Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ù†Øµ ÙÙŠ Ø­Ù‚Ù„ SSML Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠ ÙˆØ£Ù† Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…ØªØ­Ø¯Ø«ÙŠÙ† Ø§Ù„Ù†Ø´Ø·ÙŠÙ† (${activeSpeakers.map(s => s.name).join(', ')}) Ù…Ø¹Ø±ÙÙˆÙ† Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­ ÙÙŠ Ø§Ù„Ù†Øµ (Ù…Ø«Ø§Ù„: Joe: <prosody...>).`, true);
            setLoading(false);
            return;
        }

        // --- 1. Dynamic SSML Content and Speech Configuration ---
        let contentForTTS = dialogue;
        let speechConfig;

        if (speakerCount === 1) {
            // Fix: For single speaker, switch to prebuiltVoiceConfig and strip the speaker label from the text.
            const singleSpeaker = activeSpeakers[0]; // { name: "Joe", voiceName: "Achird" }

            // Strip the speaker name (e.g., "Joe:") from the beginning of each line
            contentForTTS = dialogue.split('\n')
                .map(line => line.trim())
                .filter(line => line.length > 0)
                .map(line => {
                    const regex = new RegExp(`^${singleSpeaker.name}:\\s*`, 'i');
                    return line.replace(regex, '').trim();
                })
                .join('\n');
            
            // Construct single speaker config
            speechConfig = {
                voiceConfig: {
                    prebuiltVoiceConfig: { voiceName: singleSpeaker.voiceName }
                }
            };
            
        } else {
            // Multi-Speaker Mode: Use multiSpeakerVoiceConfig and keep the speaker labels in the text.
            const speakerVoiceConfigs = activeSpeakers.map(speaker => ({
                speaker: speaker.name,
                voiceConfig: { prebuiltVoiceConfig: { voiceName: speaker.voiceName } }
            }));
            
            speechConfig = {
                multiSpeakerVoiceConfig: {
                    speakerVoiceConfigs: speakerVoiceConfigs,
                }
            };
        }
        
        // 2. Final SSML Construction (Applying global prosody for volume/amplification)
        const finalSSML = `<speak><prosody volume="+${globalVolume}dB" rate="${globalRate}x">${contentForTTS}</prosody></speak>`;
        
        const payload = {
            contents: [{ parts: [{ text: finalSSML }] }],
            generationConfig: {
                responseModalities: ["AUDIO"],
                speechConfig: speechConfig // Use the dynamically created speech config
            },
            model: TTS_MODEL 
        };
        
        // 3. API Call
        try {
            const response = await fetchWithBackoff(API_URL(TTS_MODEL, apiKey), payload, 3);
            const result = await response.json();
            
            const part = result?.candidates?.[0]?.content?.parts?.[0];
            const audioData = part?.inlineData?.data;
            const mimeType = part?.inlineData?.mimeType;

            if (audioData && mimeType && mimeType.startsWith("audio/L16")) {
                const rateMatch = mimeType.match(/rate=(\d+)/);
                const sampleRate = rateMatch ? parseInt(rateMatch[1], 10) : 24000;
                
                const pcmData = base64ToArrayBuffer(audioData);
                const pcm16 = new Int16Array(pcmData);
                const wavBlob = pcmToWav(pcm16, sampleRate);
                
                const url = URL.createObjectURL(wavBlob);
                
                // Revoke old URL before setting new one to prevent memory leaks
                if (audioUrl) {
                    URL.revokeObjectURL(audioUrl);
                }
                setAudioUrl(url);
                
                if (audioRef.current) {
                    audioRef.current.src = url;
                    audioRef.current.load();
                    // Attempt to play (browser might block it, hence the catch)
                    audioRef.current.play().catch(error => {
                        console.warn("Autoplay was prevented or playback failed. Please use the controls.", error);
                    });
                    displayMessage('âœ… ØªÙ… ØªÙˆÙ„ÙŠØ¯ ÙˆØªØ´ØºÙŠÙ„ Ø§Ù„Ø­ÙˆØ§Ø± Ø§Ù„ØµÙˆØªÙŠ Ø¨Ù†Ø¬Ø§Ø­!', false);
                } else {
                    displayMessage('âœ… ØªÙ… ØªÙˆÙ„ÙŠØ¯ Ø§Ù„ØµÙˆØª. ÙŠØ±Ø¬Ù‰ Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø²Ø± Ø§Ù„ØªØ´ØºÙŠÙ„ Ø£Ø¯Ù†Ø§Ù‡ Ù„Ù„Ø§Ø³ØªÙ…Ø§Ø¹.', false);
                }

            } else {
                const errorMsg = result.error?.message || "Invalid audio data in response. Check speaker names and SSML syntax.";
                throw new Error(errorMsg);
            }

        } catch (error) {
            console.error("TTS Error:", error);
            let msg = "âŒ Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ØªÙˆÙ„ÙŠØ¯. (ÙØ´Ù„ ÙÙŠ Ø§Ù„ÙˆØµÙˆÙ„ Ø¥Ù„Ù‰ API Ø£Ùˆ ØªÙ†Ø³ÙŠÙ‚ ØºÙŠØ± ØµØ­ÙŠØ­)";
            if (error.message.includes('400')) {
                msg = `âŒ Ø®Ø·Ø£ ÙÙŠ ØªÙ†Ø³ÙŠÙ‚ SSML: ØªØ£ÙƒØ¯ Ù…Ù† Ø£Ù† Ù†Øµ Ø§Ù„Ø­ÙˆØ§Ø± Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠ ØµØ­ÙŠØ­ØŒ Ø®Ø§ØµØ©Ù‹ Ø£Ø³Ù…Ø§Ø¡ Ø§Ù„Ù…ØªØ­Ø¯Ø«ÙŠÙ† ÙˆÙˆØ³ÙˆÙ… SSML (Prosody Ùˆ Break) Ø¨Ø§Ù„Ù„ØºØ© Ø§Ù„Ø¥Ù†Ø¬Ù„ÙŠØ²ÙŠØ©/Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© Ø§Ù„ØµØ­ÙŠØ­Ø©.`;
            } else if (error.message.includes('Server Error')) {
                const apiMessage = error.message.match(/Server Error: (.*)/)?.[1] || 'ØªÙØ§ØµÙŠÙ„ ØºÙŠØ± Ù…ØªÙˆÙØ±Ø©.';
                msg = `Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø§ØªØµØ§Ù„: ${apiMessage}. ÙŠÙØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù„Ø§Ø­Ù‚Ø§Ù‹.`;
            }
            displayMessage(msg, true);
        } finally {
            setLoading(false);
        }
    };
    
    // --- Extracted Input Components (For better structure/readability) ---

    // 1. Raw Dialogue Input Component
    const RawDialogueInputComponent = React.memo(({ value, onChange, disabled, speakerCount }) => (
        <>
            <label className="block text-lg font-bold text-gray-700 mb-2">Ø§Ù„Ù†Øµ Ø§Ù„Ø®Ø§Ù… Ø§Ù„Ù…ÙØ¯Ø®Ù„ ({speakerCount} Ù…ØªØ­Ø¯Ø«):</label>
            <textarea
                value={value}
                onChange={onChange}
                className="w-full p-3 border border-gray-300 rounded-lg shadow-sm text-gray-800 font-mono disabled:bg-gray-100"
                rows="5"
                dir="rtl"
                placeholder="ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ† Ø¨Ø§Ù„ØªÙ†Ø³ÙŠÙ‚: SpeakerName: Text... (Ù„ÙƒÙ„ Ø³Ø·Ø± Ø¬Ø¯ÙŠØ¯)"
                disabled={disabled}
            />
        </>
    ));

    // 2. SSML Instructions Component
    const SSMLInstructionsComponent = React.memo(({ value, onChange, disabled }) => (
        <>
            <label className="block text-lg font-bold text-gray-700 mt-4 mb-2">ØªØ¹Ù„ÙŠÙ…Ø§Øª Ø§Ù„Ù†Ø¨Ø±Ø© ÙˆØ§Ù„ØªØ­Ø³ÙŠÙ† (SSML):</label>
            <textarea
                value={value}
                onChange={onChange}
                className="w-full p-3 border border-gray-300 rounded-lg shadow-sm text-gray-800 text-sm disabled:bg-gray-100"
                rows="2"
                dir="rtl"
                placeholder="Ù…Ø«Ø§Ù„: Ø§Ø¬Ø¹Ù„ Joe ÙŠØªØ­Ø¯Ø« Ø¨Ù†Ø¨Ø±Ø© Ø¹Ù…ÙŠÙ‚Ø© ÙˆØ¬Ø°Ø§Ø¨Ø©. Ø£Ø¶Ù ÙØªØ±Ø§Øª ØªÙˆÙ‚Ù Ø·Ø¨ÙŠØ¹ÙŠØ©."
                disabled={disabled}
            />
        </>
    ));
    
    // 3. Final Dialogue (SSML) Component
    const FinalDialogueComponent = React.memo(({ value, onChange, disabled, speakerCount }) => (
        <div className="card p-6 bg-white border-4 border-gray-300 shadow-xl rounded-xl">
            <h2 className="text-2xl font-extrabold text-gray-800 mb-4">5. Ù†Øµ Ø§Ù„Ø­ÙˆØ§Ø± Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠ (SSML Ø§Ù„Ù…ÙØ­Ø³Ù‘Ù†)</h2>
            <textarea
                value={value}
                onChange={onChange}
                className="w-full text-area-custom p-3 border border-gray-300 rounded-lg text-gray-800 font-mono focus:ring-indigo-500 focus:border-indigo-500 disabled:bg-gray-100"
                rows="10"
                dir="rtl"
                placeholder="Joe: <prosody...>...</prosody>&#10;Jane: <prosody...>...</prosody>"
                disabled={disabled}
            />
            <p className="text-sm text-gray-500 mt-2">ØªØ£ÙƒØ¯ Ù…Ù† Ø£Ù† Ø§Ù„Ù†Øµ Ù‡Ù†Ø§ ÙŠØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ Ø£Ø³Ù…Ø§Ø¡ Ø§Ù„Ù…ØªØ­Ø¯Ø«ÙŠÙ† ÙˆÙˆØ³ÙˆÙ… SSML (Ù…Ø«Ù„ **&lt;prosody&gt;** Ùˆ **&lt;break&gt;**) Ù„Ø¶Ù…Ø§Ù† Ø£ÙØ¶Ù„ Ù†Ø·Ù‚ Ø·Ø¨ÙŠØ¹ÙŠ.</p>
        </div>
    ));

    // --- UI Component Structure ---

    const SliderLabel = ({ value, unit, min, max, title }) => (
        <div className="flex justify-between items-center mt-4">
            <span className="font-semibold text-gray-700">{title}:</span>
            <span className={`text-lg font-mono ${value === min || value === max ? 'text-red-600' : 'text-green-700'} bg-gray-100 px-3 py-1 rounded`}>
                {value}{unit}
            </span>
        </div>
    );

    const SpeakerConfig = () => (
        <div className="card p-6 bg-blue-50 border-4 border-blue-300 shadow-xl rounded-xl">
            <h2 className="text-2xl font-extrabold text-blue-800 mb-4">1. ØªØ¹Ø±ÙŠÙ Ø§Ù„Ù…ØªØ­Ø¯Ø«ÙŠÙ† ÙˆØ§Ù„Ø£ØµÙˆØ§Øª</h2>
            <p className="text-sm text-gray-600 mb-4">Ø§Ø®ØªØ± Ø¹Ø¯Ø¯ Ø§Ù„Ù…ØªØ­Ø¯Ø«ÙŠÙ† ÙˆØ®ØµØµ Ø£Ø³Ù…Ø§Ø¡Ù‡Ù… ÙˆØ£ØµÙˆØ§ØªÙ‡Ù….</p>
            
            {/* Speaker Count Toggle */}
            <div className="flex justify-center mb-6 p-1 bg-blue-200 rounded-lg shadow-inner">
                <button 
                    onClick={() => setSpeakerCount(1)}
                    className={`flex-1 p-3 font-bold rounded-lg transition duration-300 ${speakerCount === 1 ? 'bg-blue-600 text-white shadow-md' : 'text-blue-800 hover:bg-blue-300'}`}
                    disabled={loading}
                >
                    ğŸ¤ Ù…ØªØ­Ø¯Ø« ÙˆØ§Ø­Ø¯
                </button>
                <button 
                    onClick={() => setSpeakerCount(2)}
                    className={`flex-1 p-3 font-bold rounded-lg transition duration-300 ${speakerCount === 2 ? 'bg-blue-600 text-white shadow-md' : 'text-blue-800 hover:bg-blue-300'}`}
                    disabled={loading}
                >
                    ğŸ‘¥ Ù…ØªØ­Ø¯Ø«Ø§Ù†
                </button>
            </div>

            {/* Speaker Customization List (Displays only active speakers) */}
            <div className="space-y-4 max-h-60 overflow-y-auto pr-2">
                {speakers.slice(0, speakerCount).map((speaker, index) => (
                    <div key={index} className="flex flex-wrap items-center gap-3 p-3 bg-white rounded-lg shadow-md border border-blue-200">
                        <div className="flex-grow min-w-[100px]">
                            <label className="block text-xs font-medium text-gray-500 mb-1">Ø§Ø³Ù… Ø§Ù„Ù…ØªØ­Ø¯Ø« {index + 1}:</label>
                            <input 
                                type="text"
                                value={speaker.name}
                                onChange={(e) => handleSpeakerChange(index, 'name', e.target.value)}
                                className="w-full p-2 border border-gray-300 rounded-md font-bold text-center disabled:bg-gray-100"
                                maxLength="10"
                                dir="ltr"
                                placeholder={CORE_SPEAKERS[index]?.name || `Speaker ${index + 1}`}
                                disabled={loading}
                            />
                        </div>
                        <div className="flex-grow min-w-[200px]">
                            <label className="block text-xs font-medium text-gray-500 mb-1">Ø§Ù„ØµÙˆØª Ø§Ù„Ù…Ø®ØªØ§Ø±:</label>
                            <select
                                value={speaker.voiceName}
                                onChange={(e) => handleSpeakerChange(index, 'voiceName', e.target.value)}
                                className="w-full p-2 border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500 text-gray-700 disabled:bg-gray-100"
                                disabled={loading}
                            >
                                {ALL_VOICES.map(voice => (
                                    <option key={voice.name} value={voice.name}>
                                        {voice.label} ({voice.gender === "Male" ? "M" : "F"})
                                    </option>
                                ))}
                            </select>
                        </div>
                    </div>
                ))}
            </div>
            {speakerCount === 1 && (
                 <p className="mt-4 text-sm text-blue-600 border-t pt-3 font-medium">Ù…Ù„Ø§Ø­Ø¸Ø©: ÙÙŠ ÙˆØ¶Ø¹ Ø§Ù„Ù…ØªØ­Ø¯Ø« Ø§Ù„ÙˆØ§Ø­Ø¯ØŒ Ø³ÙŠØªÙ… Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ø³Ù… Ø§Ù„Ù…ØªØ­Ø¯Ø« Ø§Ù„Ø£ÙˆÙ„ ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹ ÙÙŠ Ø§Ù„Ù†Øµ.</p>
            )}
        </div>
    );

    const LLMInputSection = () => (
        <div className="card p-6 bg-emerald-50 border-4 border-emerald-300 shadow-xl rounded-xl">
            <h2 className="text-2xl font-extrabold text-emerald-800 mb-4">2. Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ø­ÙˆØ§Ø± Ø¨ÙˆØ§Ø³Ø·Ø© Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ</h2>
            
            {/* Mode Toggle */}
            <div className="flex justify-center mb-6 p-1 bg-emerald-200 rounded-lg shadow-inner">
                <button 
                    onClick={() => setCurrentMode('generate')}
                    className={`flex-1 p-3 font-bold rounded-lg transition duration-300 ${currentMode === 'generate' ? 'bg-emerald-600 text-white shadow-md' : 'text-emerald-800 hover:bg-emerald-300'}`}
                    disabled={loading}
                >
                    3. ØªÙˆÙ„ÙŠØ¯ Ø­ÙˆØ§Ø± Ù…Ù† Ù…ÙˆØ¶ÙˆØ¹
                </button>
                <button 
                    onClick={() => setCurrentMode('convert')}
                    className={`flex-1 p-3 font-bold rounded-lg transition duration-300 ${currentMode === 'convert' ? 'bg-emerald-600 text-white shadow-md' : 'text-emerald-800 hover:bg-emerald-300'}`}
                    disabled={loading}
                >
                    4. ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ù†Øµ Ø§Ù„Ø®Ø§Ù… Ø¥Ù„Ù‰ SSML
                </button>
            </div>

            {currentMode === 'generate' ? (
                // --- Mode: Auto Generate Dialogue ---
                <div>
                    <label className="block text-lg font-bold text-gray-700 mb-2">Ù…ÙˆØ¶ÙˆØ¹ Ø§Ù„Ø­ÙˆØ§Ø± Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ (3):</label>
                    <textarea
                        value={autoGenerateTopic}
                        onChange={(e) => setAutoGenerateTopic(e.target.value)}
                        className="w-full p-3 border border-gray-300 rounded-lg shadow-sm text-gray-800 disabled:bg-gray-100"
                        rows="2"
                        dir="rtl"
                        placeholder="Ù…Ø«Ø§Ù„: Ù†Ù‚Ø§Ø´ Ø¨ÙŠÙ† Joe Ùˆ Jane Ø­ÙˆÙ„ Ø£ÙØ¶Ù„ ÙˆØ¬Ù‡Ø§Øª Ø§Ù„Ø³ÙØ± Ù„Ø¹Ø§Ù… 2025."
                        disabled={loading} 
                    />
                    <button 
                        onClick={generateDialogueFromTopic} 
                        disabled={loading || !autoGenerateTopic.trim()}
                        className="btn w-full bg-emerald-600 text-white hover:bg-emerald-700 focus:ring-emerald-300 mt-4"
                    >
                        {loading ? 'Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªÙˆÙ„ÙŠØ¯...' : 'ğŸ“ ØªÙˆÙ„ÙŠØ¯ Ø­ÙˆØ§Ø± Ø®Ø§Ù…'}
                    </button>
                    <p className="mt-4 text-sm text-gray-600 border-t pt-3">Ø§Ù„Ù†Ø§ØªØ¬ Ø³ÙŠØ¸Ù‡Ø± ÙÙŠ Ù…Ø±Ø¨Ø¹ Ø§Ù„Ù†Øµ Ø§Ù„Ø®Ø§Ù… Ø£Ø¯Ù†Ø§Ù‡.</p>
                </div>
            ) : (
                // --- Mode: Convert Raw to SSML ---
                <div>
                    {/* Component 1: Raw Dialogue Input */}
                    <RawDialogueInputComponent 
                        value={rawDialogueInput}
                        onChange={(e) => setRawDialogueInput(e.target.value)}
                        disabled={loading}
                        speakerCount={speakerCount}
                    />
                    
                    {/* Component 2: SSML Instructions */}
                    <SSMLInstructionsComponent
                        value={ssmlInstructions}
                        onChange={(e) => setSSMLInstructions(e.target.value)}
                        disabled={loading}
                    />

                    <button 
                        onClick={convertToSSML} 
                        disabled={loading || !rawDialogueInput.trim()}
                        className="btn w-full bg-emerald-600 text-white hover:bg-emerald-700 focus:ring-emerald-300 mt-4"
                    >
                        {loading ? 'Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªØ­ÙˆÙŠÙ„...' : 'âš™ï¸ ØªØ­ÙˆÙŠÙ„ Ø¥Ù„Ù‰ SSML Ù…ØªÙ‚Ø¯Ù…'}
                    </button>
                </div>
            )}
        </div>
    );


    return (
        <div className="p-4 md:p-8 font-[Tajawal] bg-gray-50 min-h-screen">
            <script src="[https://cdn.tailwindcss.com](https://cdn.tailwindcss.com)"></script>
            <style>{`
                @import url('[https://fonts.googleapis.com/css2?family=Tajawal:wght@400;700;800&display=swap](https://fonts.googleapis.com/css2?family=Tajawal:wght@400;700;800&display=swap)');
                body { font-family: 'Tajawal', sans-serif; }
                .card { transition: all 0.3s ease; }
                .btn { padding: 0.75rem 1.5rem; font-weight: 700; border-radius: 0.5rem; transition: background-color 0.3s, transform 0.1s; }
                .text-area-custom { min-height: 250px; }
            `}</style>
            
            <div className="max-w-6xl mx-auto">
                <header className="text-center mb-10">
                    <h1 className="text-4xl font-extrabold text-blue-700 mb-2">ğŸ™ï¸ Ù…ÙˆÙ„Ø¯ Ø§Ù„Ø­ÙˆØ§Ø±Ø§Øª Ø§Ù„Ù…ØªØ¹Ø¯Ø¯Ø© Ø§Ù„Ø£ØµÙˆØ§Øª (SSML)</h1>
                    <p className="text-lg text-gray-600 font-medium">Ù†Ø¸Ø§Ù… Ù…ØªÙƒØ§Ù…Ù„ Ù„ØªÙˆÙ„ÙŠØ¯ Ø§Ù„Ù…Ù‚Ø§Ù„Ø§ØªØŒ ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ù†ØµÙˆØµØŒ ÙˆØ§Ù„ØªØ­ÙƒÙ… ÙÙŠ Ø§Ù„Ù†Ø¨Ø±Ø© Ø§Ù„ØµÙˆØªÙŠØ©</p>
                </header>

                {/* Error/Success Message Display */}
                {errorMessage && (
                    <div className={`p-4 mb-6 rounded-xl font-medium ${errorMessage.isError ? 'bg-red-100 text-red-800 border border-red-300' : 'bg-green-100 text-green-800 border border-green-300'}`}>
                        {errorMessage.message}
                    </div>
                )}

                {/* Main Layout Grid */}
                <div className="grid grid-cols-1 lg:grid-cols-3 gap-8">
                    
                    {/* Column 1: Speaker Configuration */}
                    <div className="lg:col-span-1 space-y-8">
                        <SpeakerConfig />
                    </div>

                    {/* Column 2: LLM Input and Conversion */}
                    <div className="lg:col-span-2 space-y-8">
                        <LLMInputSection />
                    </div>
                </div>
                
                {/* Final Dialogue Area and Global Controls */}
                <div className="mt-10 grid grid-cols-1 lg:grid-cols-3 gap-8">
                    <div className="lg:col-span-2">
                        {/* Component 3: Final Dialogue (SSML) */}
                        <FinalDialogueComponent
                            value={dialogue}
                            onChange={(e) => setDialogue(e.target.value)}
                            disabled={loading}
                            speakerCount={speakerCount}
                        />
                    </div>
                    
                    {/* Column 3: Global Controls & Final Output */}
                    <div className="lg:col-span-1 space-y-8">
                        {/* Global Controls */}
                        <div className="card p-6 bg-yellow-50 border-4 border-yellow-300 shadow-xl rounded-xl">
                            {/* UPDATED TITLE */}
                            <h2 className="text-2xl font-extrabold text-yellow-800 mb-4">6. Ø§Ù„ØªØ­ÙƒÙ… Ø§Ù„ÙƒÙ„ÙŠ ÙˆØ§Ù„ØªØ¶Ø®ÙŠÙ… Ø§Ù„ØµÙˆØªÙŠ</h2>
                            
                            {/* Volume Slider (Amplification) */}
                            <SliderLabel title="ğŸ”Š ØªØ¶Ø®ÙŠÙ…/Ø±ÙØ¹ Ù…Ø³ØªÙˆÙ‰ Ø§Ù„ØµÙˆØª Ø§Ù„ÙƒÙ„ÙŠ" value={globalVolume} unit="dB" min={0} max={10} />
                            <input 
                                type="range" 
                                min="0" 
                                max="10" 
                                value={globalVolume} 
                                onChange={(e) => setGlobalVolume(parseInt(e.target.value))}
                                className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer range-lg focus:outline-none focus:ring-2 focus:ring-yellow-500 disabled:opacity-50"
                                disabled={loading}
                            />
                            <p className="text-sm text-gray-500 mt-1">ÙŠÙØ·Ø¨Ù‚ Ù‡Ø°Ø§ Ø§Ù„ØªØ­ÙƒÙ… ØªØ¶Ø®ÙŠÙ…Ø§Ù‹ Ø¨Ø§Ù„Ø¯ÙŠØ³ÙŠØ¨Ù„ (dB) Ø¹Ù„Ù‰ ÙƒØ§Ù…Ù„ Ø§Ù„Ù…Ù„Ù Ø§Ù„ØµÙˆØªÙŠØŒ Ù…Ù…Ø§ ÙŠØ¹Ø§Ø¯Ù„ ÙˆØ¸ÙŠÙØ© "Volume Booster" Ù‚Ø¨Ù„ Ø§Ù„ØªÙˆÙ„ÙŠØ¯. (Ø§Ù„Ù‚ÙŠÙ…Ø© Ø§Ù„Ù‚ØµÙˆÙ‰: 10dB).</p>
                            
                            {/* Rate Slider */}
                            <SliderLabel title="âš¡ Ø³Ø±Ø¹Ø© Ø§Ù„Ù‚Ø±Ø§Ø¡Ø© Ø§Ù„ÙƒÙ„ÙŠØ©" value={globalRate.toFixed(2)} unit="x" min={0.8} max={1.5} />
                            <input 
                                type="range" 
                                min="0.8" 
                                max="1.5" 
                                step="0.05"
                                value={globalRate} 
                                onChange={(e) => setGlobalRate(parseFloat(e.target.value))}
                                className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer range-lg focus:outline-none focus:ring-2 focus:ring-yellow-500 disabled:opacity-50"
                                disabled={loading}
                            />
                            
                            <button 
                                onClick={generateMultiSpeakerAudio} 
                                disabled={loading || dialogue.trim().length === 0}
                                className="btn w-full bg-indigo-600 text-white hover:bg-indigo-700 focus:ring-indigo-300 mt-6 disabled:bg-gray-400"
                            >
                                {loading ? 'Ø¬Ø§Ø±ÙŠ ØªÙˆÙ„ÙŠØ¯ Ø§Ù„ØµÙˆØª...' : 'â–¶ï¸ ØªÙˆÙ„ÙŠØ¯ ÙˆØªØ´ØºÙŠÙ„ Ø§Ù„Ø­ÙˆØ§Ø± Ø§Ù„ØµÙˆØªÙŠ'}
                            </button>
                            
                            {/* Audio Player */}
                            <div className="mt-4 p-3 bg-white rounded-lg border">
                                {audioUrl ? (
                                    <audio ref={audioRef} controls className="w-full"></audio>
                                ) : (
                                    <p className="text-center text-gray-500 italic text-sm">Ø³ÙŠØ¸Ù‡Ø± Ù…Ø´ØºÙ„ Ø§Ù„ØµÙˆØª Ù‡Ù†Ø§.</p>
                                )}
                            </div>
                        </div>
                    </div>
                </div>

            </div>
        </div>
    );
}

export default App;
