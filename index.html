import React, { useState, useEffect, useRef, useCallback, useMemo } from 'react';

// --- Global API Configuration ---
const LLM_MODEL = 'gemini-2.5-flash-preview-09-2025';
const TTS_MODEL = 'gemini-2.5-flash-preview-tts';
const apiKey = ""; // API key is provided by the runtime environment

const API_URL = (model, key) =>
    `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${key}`;


// قائمة الأصوات المتاحة
const ALL_VOICES = [
    // أصوات ذكورية (Male Voices)
    { name: "Achird", label: "Achird (قوي وعميق)", gender: "Male" },
    { name: "Charon", label: "Charon (إخباري ومحترف)", gender: "Male" },
    { name: "Iapetus", label: "Iapetus (واضح ومعبر)", gender: "Male" },
    { name: "Kore", label: "Kore (قوي وواثق)", gender: "Male" },
    { name: "Orus", label: "Orus (حازم ومحترف)", gender: "Male" },
    { name: "Fenrir", label: "Fenrir (متحمس وديناميكي)", gender: "Male" },
    { name: "Umbriel", label: "Umbriel (دافئ وودود)", gender: "Male" },
    { name: "Sadachbia", label: "Sadachbia (عميق ومميز)", gender: "Male" },

    // أصوات أنثوية (Female Voices)
    { name: "Despina", label: "Despina (ناعم وودود)", gender: "Female" },
    { name: "Aoede", label: "Aoede (منعش وواضح)", gender: "Female" },
    { name: "Leda", label: "Leda (شاب ودافئ)", gender: "Female" },
    { name: "Callirrhoe", label: "Callirrhoe (هادئ وذكي)", gender: "Female" },
    { name: "Zephyr", label: "Zephyr (مشرق ومعبر)", gender: "Female" },
    { name: "Achernar", label: "Achernar (أنيق واحترافي)", gender: "Female" },
];

// الإعداد الأولي والأساسي للمتحدثين
const CORE_SPEAKERS = [
    { name: "Joe", voiceName: "Achird" }, // المتحدث 1
    { name: "Jane", voiceName: "Despina" }, // المتحدث 2
];

// --- Utility Functions ---

/**
 * ينظف ناتج LLM من أي كتل كود (```) أو مقدمات غير ضرورية.
 * @param {string} text - النص الخام من LLM.
 * @returns {string} النص النظيف.
 */
const cleanLLMOutput = (text) => {
    if (!text) return "";
    let cleaned = text.trim().replace(/^```[a-zA-Z]*\s*\n|```$/gs, '').trim();
    const unnecessaryPrefixes = [
        /^\s*إليك الحوار:\s*/i, /^\s*إليك الحوار الخام:\s*/i, /^\s*الحوار المُحسَّن:\s*/i,
        /^\s*إليك النص المُحسَّن:\s*/i, /^\s*إليك النص بصيغة SSML:\s*/i,
    ];
    for (const prefix of unnecessaryPrefixes) {
        cleaned = cleaned.replace(prefix, '').trim();
    }
    return cleaned;
};

/**
 * دالة مساعدة لجلب البيانات مع آلية إعادة المحاولة (Exponential Backoff).
 */
const fetchWithBackoff = async (url, payload, maxRetries = 3) => {
    for (let currentRetry = 0; currentRetry < maxRetries; currentRetry++) {
        try {
            const response = await fetch(url, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });
            if (response.ok) return response;
            
            let errorBody = {};
            try { 
                // Attempt to parse JSON error body
                errorBody = await response.json(); 
            } catch (e) { 
                // Fallback for non-JSON errors
                errorBody = { error: { message: response.statusText || `HTTP Status ${response.status}.` } }; 
            }
            
            const errorMsg = errorBody.error?.message || 'Unknown Server Error';
            throw new Error(`Server Error: ${response.status} - ${errorMsg}`);
        } catch (error) {
            // Do not retry on Auth errors (401, 403, 400)
            if (currentRetry === maxRetries - 1 || error.message.includes('401') || error.message.includes('403') || error.message.includes('400')) {
                throw error;
            }
            // Exponential backoff delay
            const delay = Math.pow(2, currentRetry) * 1000 + (Math.random() * 500);
            await new Promise(resolve => setTimeout(resolve, delay));
            // Log retry silently
        }
    }
    // Should be unreachable if maxRetries > 0, but added for safety
    throw new Error('Maximum retry attempts reached.');
};

// Audio Conversion utilities 
const base64ToArrayBuffer = (base64) => {
    const binaryString = atob(base64);
    const len = binaryString.length;
    const bytes = new Uint8Array(len);
    for (let i = 0; i < len; i++) {
        bytes[i] = binaryString.charCodeAt(i);
    }
    return bytes.buffer;
};

const pcmToWav = (pcm16Data, sampleRate) => {
    const numChannels = 1;
    const bitDepth = 16;
    const numSamples = pcm16Data.length;
    const dataSize = numSamples * numChannels * (bitDepth / 8);
    const buffer = new ArrayBuffer(44 + dataSize);
    const view = new DataView(buffer);
    let offset = 0;

    const writeString = (view, offset, string) => {
        for (let i = 0; i < string.length; i++) { view.setUint8(offset + i, string.charCodeAt(i)); }
    };
    const writeUint32 = (view, offset, value) => { view.setUint32(offset, value, true); };
    const writeUint16 = (view, offset, value) => { view.setUint16(offset, value, true); };

    // RIFF chunk descriptor
    writeString(view, offset, 'RIFF'); offset += 4; 
    writeUint32(view, offset, 36 + dataSize); offset += 4; 
    writeString(view, offset, 'WAVE'); offset += 4; 

    // fmt sub-chunk
    writeString(view, offset, 'fmt '); offset += 4; 
    writeUint32(view, offset, 16); offset += 4; 
    writeUint16(view, offset, 1); offset += 2;
    writeUint16(view, offset, numChannels); offset += 2; 
    writeUint32(view, offset, sampleRate); offset += 4; 
    writeUint32(view, offset, sampleRate * numChannels * (bitDepth / 8)); offset += 4;
    writeUint16(view, offset, numChannels * (bitDepth / 8)); offset += 2; 
    writeUint16(view, offset, bitDepth); offset += 2; 

    // data sub-chunk
    writeString(view, offset, 'data'); offset += 4; 
    writeUint32(view, offset, dataSize); offset += 4; 

    const pcmOffset = 44;
    for (let i = 0; i < numSamples; i++) {
        // PCM data is signed 16-bit
        view.setInt16(pcmOffset + i * 2, pcm16Data[i], true);
    }

    return new Blob([buffer], { type: 'audio/wav' });
};


// --- React Component ---

export const App = () => {
    const [speakerCount, setSpeakerCount] = useState(2); 
    const [speakers, setSpeakers] = useState(CORE_SPEAKERS); 
    
    const [dialogue, setDialogue] = useState(`Joe: <prosody pitch="medium" rate="1.0x" volume="+2dB">مرحباً جين، <break time="500ms"/> هل أنت مستعدة لمناقشة التقرير الجديد؟</prosody>\nJane: <prosody pitch="medium" rate="1.0x" volume="+2dB">بالتأكيد جو، لنبدأ بتحليل الأرقام.</prosody>`);
    const [rawDialogueInput, setRawDialogueInput] = useState(`Joe: مرحباً جين، هل أنت مستعدة لمناقشة التقرير الجديد؟\nJane: بالتأكيد جو، لنبدأ بتحليل الأرقام.`);
    const [loading, setLoading] = useState(false);
    const [audioUrl, setAudioUrl] = useState(null);
    const [errorMessage, setErrorMessage] = useState(null);
    const [globalVolume, setGlobalVolume] = useState(0); 
    const [globalRate, setGlobalRate] = useState(1.0);
    const [currentMode, setCurrentMode] = useState('convert');
    const [autoGenerateTopic, setAutoGenerateTopic] = useState('حوار تعليمي عن فوائد الذكاء الاصطناعي في مجال التعليم.');
    const [ssmlInstructions, setSSMLInstructions] = useState('طبّق نبرة "قوية وجذابة" على Joe ونبرة "لطيفة ومعبرة" على Jane. أضف فترات توقف طبيعية واستخدم نغمة حوارية.');
    const audioRef = useRef(null);

    // DIsplay Message Callback
    const displayMessage = useCallback((message, isError = false) => {
        setErrorMessage({ message, isError });
        setTimeout(() => setErrorMessage(null), 8000);
    }, []);

    // 1. Effect to manage speakers state based on speakerCount change
    useEffect(() => {
        // Ensure speakers array is initialized up to CORE_SPEAKERS size for safety
        const safeSpeakers = [...speakers];
        while (safeSpeakers.length < CORE_SPEAKERS.length) {
            safeSpeakers.push(CORE_SPEAKERS[safeSpeakers.length]);
        }
        
        if (speakerCount === 1) {
            // Keep only the first speaker and their current configuration
            setSpeakers(prev => [prev[0]]);
            
            // Attempt to simplify dialogue for one speaker
            const singleSpeakerName = CORE_SPEAKERS[0].name;
            const otherSpeakerName = CORE_SPEAKERS[1].name;

            if (rawDialogueInput.includes(otherSpeakerName + ':') || dialogue.includes(otherSpeakerName + ':')) {
                // Filter out lines from the second speaker
                const simplifiedRaw = rawDialogueInput.split('\n')
                    .filter(line => !line.startsWith(otherSpeakerName + ':') && line.trim() !== '')
                    .map(line => line.startsWith(singleSpeakerName + ':') ? line : `${singleSpeakerName}: ${line.replace(/^\w+:\s*/, '')}`)
                    .join('\n') || `${singleSpeakerName}: مرحبا، أنا المتحدث الوحيد هنا.`;

                const simplifiedSSML = dialogue.split('\n')
                    .filter(line => !line.startsWith(otherSpeakerName + ':') && line.trim() !== '')
                    .map(line => line.startsWith(singleSpeakerName + ':') ? line : `${singleSpeakerName}: ${line.replace(/^\w+:\s*/, '')}`)
                    .join('\n') || `${singleSpeakerName}: <prosody pitch="medium" rate="1.0x" volume="+2dB">مرحبا، أنا المتحدث الوحيد هنا.</prosody>`;

                setRawDialogueInput(simplifiedRaw);
                setDialogue(simplifiedSSML);
                displayMessage('⚠️ تم التبديل إلى متحدث واحد. تم تعديل الحوارات تلقائياً لتناسب المتحدث الأول فقط.', true);
            }

        } else if (speakerCount === 2) {
            // Restore both speakers, ensuring custom changes are kept if possible
            setSpeakers(CORE_SPEAKERS.map((coreSpeaker, index) => {
                const existing = safeSpeakers[index];
                return existing ? existing : coreSpeaker;
            }));
        }
    // Corrected Dependencies
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [speakerCount, displayMessage, dialogue, rawDialogueInput]); 
    
    // --- Cleanup Effect for Audio URL ---
    useEffect(() => {
        const oldUrl = audioRef.current?.src;
        return () => {
            if (oldUrl && oldUrl.startsWith('blob:')) {
                URL.revokeObjectURL(oldUrl);
            }
        };
    }, [audioUrl]);


    const speakerNames = useMemo(() => speakers.slice(0, speakerCount).map(s => s.name).join(', '), [speakers, speakerCount]);

    // --- Speaker Management ---

    const handleSpeakerChange = (index, field, value) => {
        setSpeakers(prevSpeakers => {
            const newSpeakers = [...prevSpeakers];
            // Ensure the array has enough space if index is at the current limit
            if (!newSpeakers[index]) {
                 newSpeakers[index] = CORE_SPEAKERS[index] || { name: `Speaker ${index + 1}`, voiceName: ALL_VOICES[0].name };
            }

            // Only update if the index is valid for the current count
            if (index < speakerCount) {
                newSpeakers[index] = { ...newSpeakers[index], [field]: value };
            }
            return newSpeakers;
        });
    };

    // --- LLM Generation Functions ---

    // Function to generate raw dialogue based on a topic
    const generateDialogueFromTopic = async () => {
        if (!autoGenerateTopic.trim()) {
            displayMessage('يرجى كتابة موضوع لتوليد الحوار.', true);
            return;
        }
        setLoading(true);
        setErrorMessage(null);

        const activeSpeakers = speakers.slice(0, speakerCount);
        const speakerList = activeSpeakers.map(s => s.name).join(' و ');
        
        const dialogueFormat = `يجب أن يكون الناتج نصًا خامًا باللغة العربية، منسقًا حصريًا على شكل 'SpeakerName: Dialogue' لكل سطر جديد.`;

        const systemPrompt = `أنت خبير في كتابة النصوص والحوارات. مهمتك هي كتابة حوار/نص باللغة العربية الفصحى (أو لهجة محايدة) حول الموضوع: "${autoGenerateTopic}". استخدم المتحدثين التاليين: ${speakerList}. ${dialogueFormat} لا تضف أي وسوم SSML، ولا أرقام، ولا مقدمات، ولا خاتمات. اجعل الحوار/النص من 6 إلى 8 جمل.`;
        
        const payload = {
            contents: [{ parts: [{ text: "قم بتوليد الحوار الآن." }] }],
            systemInstruction: { parts: [{ text: systemPrompt }] },
            model: LLM_MODEL 
        };

        try {
            const response = await fetchWithBackoff(API_URL(LLM_MODEL, apiKey), payload, 3);
            const result = await response.json();
            const text = result.candidates?.[0]?.content?.parts?.[0]?.text;

            if (text) {
                const cleanedText = cleanLLMOutput(text);

                // Basic validation for structure (expecting at least one colon for speaker format)
                if (cleanedText.length < 20 || !cleanedText.includes(':')) {
                     throw new Error('LLM returned an invalid dialogue format, expected speaker names followed by a colon.');
                }
                
                // Ensure text starts with an active speaker name, or prepend if missing (mostly for 1 speaker mode, though LLM should prepend)
                const startsWithActiveSpeaker = activeSpeakers.some(s => 
                    cleanedText.split('\n')[0]?.startsWith(s.name + ':')
                );

                let finalRaw = cleanedText;
                if (speakerCount === 1 && !startsWithActiveSpeaker) {
                    // Prepend the single speaker's name if the model was too raw
                    finalRaw = `${activeSpeakers[0].name}: ${cleanedText.replace(/^\s*/, '')}`;
                }

                setRawDialogueInput(finalRaw);
                displayMessage('✅ تم توليد الحوار الخام بنجاح. يمكنك الآن تحويله إلى SSML.', false);
            } else {
                throw new Error('LLM did not return text or response structure was invalid.');
            }
        } catch (error) {
            console.error("Generation Error:", error);
            const msg = error.message.includes('400') ? 
                '❌ خطأ في الطلب: تأكد من أن موضوع الحوار واضح ومناسب.' : 
                `❌ فشل توليد الحوار. رسالة الخطأ: ${error.message}`;
            displayMessage(msg, true);
        } finally {
            setLoading(false);
        }
    };

    // Function to convert raw dialogue to SSML based on instructions
    const convertToSSML = async () => {
        if (!rawDialogueInput.trim()) {
            displayMessage('يرجى كتابة النص الخام في مربع الإدخال أولاً.', true);
            return;
        }
        setLoading(true);
        setErrorMessage(null);

        const systemPrompt = `أنت خبير في تنسيق نصوص SSML للتركيب الصوتي (TTS). مهمتك هي أخذ الحوار النصي الخام وتطبيق وسوم SSML الديناميكية (<prosody pitch/rate/volume/break>) بناءً على التعليمات المخصصة: "${ssmlInstructions}". ركّز على استخدام وسوم <break time="Xms"/> في فواصل الجمل الطبيعية ومواضع التوقف لإضافة إيقاع شبيه بالنطق البشري، وقم بتعديل طبقة الصوت (pitch) أو معدل القراءة (rate) بشكل طفيف لمحاكاة الأداء الصوتي المطلوب. يجب أن يكون الناتج نصًا خامًا باللغة العربية، منسقًا حصريًا على شكل 'SpeakerName: <SSML> Dialogue </SSML>'، مع الحرص على عدم فقدان اسم المتحدث (SpeakerName). لا تضف أي نص تفسيري أو مقدمات أو خاتمات. استخدم المتحدثين المحددين: ${speakerNames}.
        الحوار الخام: ${rawDialogueInput}`;

        const payload = {
            contents: [{ parts: [{ text: "قم بتطبيق التعليمات على الحوار وتقديم النص المُحسّن فقط." }] }],
            systemInstruction: { parts: [{ text: systemPrompt }] },
            model: LLM_MODEL 
        };

        try {
            const response = await fetchWithBackoff(API_URL(LLM_MODEL, apiKey), payload, 3);
            const result = await response.json();
            const text = result.candidates?.[0]?.content?.parts?.[0]?.text;

            if (text) {
                const cleanedText = cleanLLMOutput(text);

                if (!cleanedText.includes('<prosody') || !cleanedText.includes(':')) {
                    // Fallback to simple SSML if LLM fails to add advanced tags
                    let simpleSSML = rawDialogueInput.split('\n')
                        .map(line => line.trim())
                        .filter(line => line.length > 0)
                        .map(line => {
                            const parts = line.split(':');
                            if (parts.length >= 2) {
                                const speaker = parts[0].trim();
                                const dialogueText = parts.slice(1).join(':').trim();
                                // Only add SSML if speaker is one of the active speakers
                                if (speakers.slice(0, speakerCount).some(s => s.name === speaker)) {
                                     return `${speaker}: <prosody pitch="medium" rate="1.0x" volume="+0dB">${dialogueText}</prosody>`;
                                }
                            }
                            return '';
                        }).filter(line => line.includes('<prosody')).join('\n');

                    if (simpleSSML.length > 0) {
                        setDialogue(simpleSSML);
                        displayMessage('⚠️ فشل LLM في إضافة SSML متقدمة. تم إضافة تنسيق SSML أساسي. قم بمراجعة التعليمات.', true);
                    } else {
                         throw new Error('LLM failed to apply SSML tags or basic SSML structure is invalid. Please check the raw text format (Speaker: Dialogue) and ensure speaker names are correct.');
                    }
                } else {
                    setDialogue(cleanedText);
                    displayMessage('✅ تم تحويل النص الخام وتطبيق وسوم SSML بنجاح. النص جاهز للتوليد الصوتي.', false);
                }

            } else {
                throw new Error('LLM did not return text or response structure was invalid.');
            }

        } catch (error) {
            console.error("SSML Conversion Error:", error);
            const msg = error.message.includes('400') ? 
                '❌ خطأ في الطلب: تأكد من أن التعليمات واضحة وصيغة الحوار الخام صحيحة.' : 
                `❌ فشل تحويل النص إلى SSML. رسالة الخطأ: ${error.message}`;
            displayMessage(msg, true);
        } finally {
            setLoading(false);
        }
    };

    // --- Core TTS Generation Function ---
    const generateMultiSpeakerAudio = async () => {
        setLoading(true);
        setErrorMessage(null);

        // Get active speakers
        const activeSpeakers = speakers.slice(0, speakerCount);

        // Validation: Check if all active speakers are represented in the dialogue
        const requiredDialogueFormat = activeSpeakers.every(s => dialogue.includes(`${s.name}:`));
        if (!dialogue.trim() || !requiredDialogueFormat) {
            displayMessage(`يرجى التأكد من وجود نص في حقل SSML النهائي وأن جميع المتحدثين النشطين (${activeSpeakers.map(s => s.name).join(', ')}) معرفون بشكل صحيح في النص (مثال: Joe: <prosody...>).`, true);
            setLoading(false);
            return;
        }

        // --- 1. Dynamic SSML Content and Speech Configuration ---
        let contentForTTS = dialogue;
        let speechConfig;

        if (speakerCount === 1) {
            // Fix: For single speaker, switch to prebuiltVoiceConfig and strip the speaker label from the text.
            const singleSpeaker = activeSpeakers[0]; // { name: "Joe", voiceName: "Achird" }

            // Strip the speaker name (e.g., "Joe:") from the beginning of each line
            contentForTTS = dialogue.split('\n')
                .map(line => line.trim())
                .filter(line => line.length > 0)
                .map(line => {
                    const regex = new RegExp(`^${singleSpeaker.name}:\\s*`, 'i');
                    return line.replace(regex, '').trim();
                })
                .join('\n');
            
            // Construct single speaker config
            speechConfig = {
                voiceConfig: {
                    prebuiltVoiceConfig: { voiceName: singleSpeaker.voiceName }
                }
            };
            
        } else {
            // Multi-Speaker Mode: Use multiSpeakerVoiceConfig and keep the speaker labels in the text.
            const speakerVoiceConfigs = activeSpeakers.map(speaker => ({
                speaker: speaker.name,
                voiceConfig: { prebuiltVoiceConfig: { voiceName: speaker.voiceName } }
            }));
            
            speechConfig = {
                multiSpeakerVoiceConfig: {
                    speakerVoiceConfigs: speakerVoiceConfigs,
                }
            };
        }
        
        // 2. Final SSML Construction (Applying global prosody for volume/amplification)
        const finalSSML = `<speak><prosody volume="+${globalVolume}dB" rate="${globalRate}x">${contentForTTS}</prosody></speak>`;
        
        const payload = {
            contents: [{ parts: [{ text: finalSSML }] }],
            generationConfig: {
                responseModalities: ["AUDIO"],
                speechConfig: speechConfig // Use the dynamically created speech config
            },
            model: TTS_MODEL 
        };
        
        // 3. API Call
        try {
            const response = await fetchWithBackoff(API_URL(TTS_MODEL, apiKey), payload, 3);
            const result = await response.json();
            
            const part = result?.candidates?.[0]?.content?.parts?.[0];
            const audioData = part?.inlineData?.data;
            const mimeType = part?.inlineData?.mimeType;

            if (audioData && mimeType && mimeType.startsWith("audio/L16")) {
                const rateMatch = mimeType.match(/rate=(\d+)/);
                const sampleRate = rateMatch ? parseInt(rateMatch[1], 10) : 24000;
                
                const pcmData = base64ToArrayBuffer(audioData);
                const pcm16 = new Int16Array(pcmData);
                const wavBlob = pcmToWav(pcm16, sampleRate);
                
                const url = URL.createObjectURL(wavBlob);
                
                // Revoke old URL before setting new one to prevent memory leaks
                if (audioUrl) {
                    URL.revokeObjectURL(audioUrl);
                }
                setAudioUrl(url);
                
                if (audioRef.current) {
                    audioRef.current.src = url;
                    audioRef.current.load();
                    // Attempt to play (browser might block it, hence the catch)
                    audioRef.current.play().catch(error => {
                        console.warn("Autoplay was prevented or playback failed. Please use the controls.", error);
                    });
                    displayMessage('✅ تم توليد وتشغيل الحوار الصوتي بنجاح!', false);
                } else {
                    displayMessage('✅ تم توليد الصوت. يرجى استخدام زر التشغيل أدناه للاستماع.', false);
                }

            } else {
                const errorMsg = result.error?.message || "Invalid audio data in response. Check speaker names and SSML syntax.";
                throw new Error(errorMsg);
            }

        } catch (error) {
            console.error("TTS Error:", error);
            let msg = "❌ خطأ في التوليد. (فشل في الوصول إلى API أو تنسيق غير صحيح)";
            if (error.message.includes('400')) {
                msg = `❌ خطأ في تنسيق SSML: تأكد من أن نص الحوار النهائي صحيح، خاصةً أسماء المتحدثين ووسوم SSML (Prosody و Break) باللغة الإنجليزية/العربية الصحيحة.`;
            } else if (error.message.includes('Server Error')) {
                const apiMessage = error.message.match(/Server Error: (.*)/)?.[1] || 'تفاصيل غير متوفرة.';
                msg = `خطأ في الاتصال: ${apiMessage}. يُرجى المحاولة لاحقاً.`;
            }
            displayMessage(msg, true);
        } finally {
            setLoading(false);
        }
    };
    
    // --- Extracted Input Components (For better structure/readability) ---

    // 1. Raw Dialogue Input Component
    const RawDialogueInputComponent = React.memo(({ value, onChange, disabled, speakerCount }) => (
        <>
            <label className="block text-lg font-bold text-gray-700 mb-2">النص الخام المُدخل ({speakerCount} متحدث):</label>
            <textarea
                value={value}
                onChange={onChange}
                className="w-full p-3 border border-gray-300 rounded-lg shadow-sm text-gray-800 font-mono disabled:bg-gray-100"
                rows="5"
                dir="rtl"
                placeholder="يجب أن يكون بالتنسيق: SpeakerName: Text... (لكل سطر جديد)"
                disabled={disabled}
            />
        </>
    ));

    // 2. SSML Instructions Component
    const SSMLInstructionsComponent = React.memo(({ value, onChange, disabled }) => (
        <>
            <label className="block text-lg font-bold text-gray-700 mt-4 mb-2">تعليمات النبرة والتحسين (SSML):</label>
            <textarea
                value={value}
                onChange={onChange}
                className="w-full p-3 border border-gray-300 rounded-lg shadow-sm text-gray-800 text-sm disabled:bg-gray-100"
                rows="2"
                dir="rtl"
                placeholder="مثال: اجعل Joe يتحدث بنبرة عميقة وجذابة. أضف فترات توقف طبيعية."
                disabled={disabled}
            />
        </>
    ));
    
    // 3. Final Dialogue (SSML) Component
    const FinalDialogueComponent = React.memo(({ value, onChange, disabled, speakerCount }) => (
        <div className="card p-6 bg-white border-4 border-gray-300 shadow-xl rounded-xl">
            <h2 className="text-2xl font-extrabold text-gray-800 mb-4">5. نص الحوار النهائي (SSML المُحسّن)</h2>
            <textarea
                value={value}
                onChange={onChange}
                className="w-full text-area-custom p-3 border border-gray-300 rounded-lg text-gray-800 font-mono focus:ring-indigo-500 focus:border-indigo-500 disabled:bg-gray-100"
                rows="10"
                dir="rtl"
                placeholder="Joe: <prosody...>...</prosody>&#10;Jane: <prosody...>...</prosody>"
                disabled={disabled}
            />
            <p className="text-sm text-gray-500 mt-2">تأكد من أن النص هنا يحتوي على أسماء المتحدثين ووسوم SSML (مثل **&lt;prosody&gt;** و **&lt;break&gt;**) لضمان أفضل نطق طبيعي.</p>
        </div>
    ));

    // --- UI Component Structure ---

    const SliderLabel = ({ value, unit, min, max, title }) => (
        <div className="flex justify-between items-center mt-4">
            <span className="font-semibold text-gray-700">{title}:</span>
            <span className={`text-lg font-mono ${value === min || value === max ? 'text-red-600' : 'text-green-700'} bg-gray-100 px-3 py-1 rounded`}>
                {value}{unit}
            </span>
        </div>
    );

    const SpeakerConfig = () => (
        <div className="card p-6 bg-blue-50 border-4 border-blue-300 shadow-xl rounded-xl">
            <h2 className="text-2xl font-extrabold text-blue-800 mb-4">1. تعريف المتحدثين والأصوات</h2>
            <p className="text-sm text-gray-600 mb-4">اختر عدد المتحدثين وخصص أسماءهم وأصواتهم.</p>
            
            {/* Speaker Count Toggle */}
            <div className="flex justify-center mb-6 p-1 bg-blue-200 rounded-lg shadow-inner">
                <button 
                    onClick={() => setSpeakerCount(1)}
                    className={`flex-1 p-3 font-bold rounded-lg transition duration-300 ${speakerCount === 1 ? 'bg-blue-600 text-white shadow-md' : 'text-blue-800 hover:bg-blue-300'}`}
                    disabled={loading}
                >
                    🎤 متحدث واحد
                </button>
                <button 
                    onClick={() => setSpeakerCount(2)}
                    className={`flex-1 p-3 font-bold rounded-lg transition duration-300 ${speakerCount === 2 ? 'bg-blue-600 text-white shadow-md' : 'text-blue-800 hover:bg-blue-300'}`}
                    disabled={loading}
                >
                    👥 متحدثان
                </button>
            </div>

            {/* Speaker Customization List (Displays only active speakers) */}
            <div className="space-y-4 max-h-60 overflow-y-auto pr-2">
                {speakers.slice(0, speakerCount).map((speaker, index) => (
                    <div key={index} className="flex flex-wrap items-center gap-3 p-3 bg-white rounded-lg shadow-md border border-blue-200">
                        <div className="flex-grow min-w-[100px]">
                            <label className="block text-xs font-medium text-gray-500 mb-1">اسم المتحدث {index + 1}:</label>
                            <input 
                                type="text"
                                value={speaker.name}
                                onChange={(e) => handleSpeakerChange(index, 'name', e.target.value)}
                                className="w-full p-2 border border-gray-300 rounded-md font-bold text-center disabled:bg-gray-100"
                                maxLength="10"
                                dir="ltr"
                                placeholder={CORE_SPEAKERS[index]?.name || `Speaker ${index + 1}`}
                                disabled={loading}
                            />
                        </div>
                        <div className="flex-grow min-w-[200px]">
                            <label className="block text-xs font-medium text-gray-500 mb-1">الصوت المختار:</label>
                            <select
                                value={speaker.voiceName}
                                onChange={(e) => handleSpeakerChange(index, 'voiceName', e.target.value)}
                                className="w-full p-2 border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500 text-gray-700 disabled:bg-gray-100"
                                disabled={loading}
                            >
                                {ALL_VOICES.map(voice => (
                                    <option key={voice.name} value={voice.name}>
                                        {voice.label} ({voice.gender === "Male" ? "M" : "F"})
                                    </option>
                                ))}
                            </select>
                        </div>
                    </div>
                ))}
            </div>
            {speakerCount === 1 && (
                 <p className="mt-4 text-sm text-blue-600 border-t pt-3 font-medium">ملاحظة: في وضع المتحدث الواحد، سيتم استخدام اسم المتحدث الأول تلقائياً في النص.</p>
            )}
        </div>
    );

    const LLMInputSection = () => (
        <div className="card p-6 bg-emerald-50 border-4 border-emerald-300 shadow-xl rounded-xl">
            <h2 className="text-2xl font-extrabold text-emerald-800 mb-4">2. إعداد الحوار بواسطة الذكاء الاصطناعي</h2>
            
            {/* Mode Toggle */}
            <div className="flex justify-center mb-6 p-1 bg-emerald-200 rounded-lg shadow-inner">
                <button 
                    onClick={() => setCurrentMode('generate')}
                    className={`flex-1 p-3 font-bold rounded-lg transition duration-300 ${currentMode === 'generate' ? 'bg-emerald-600 text-white shadow-md' : 'text-emerald-800 hover:bg-emerald-300'}`}
                    disabled={loading}
                >
                    3. توليد حوار من موضوع
                </button>
                <button 
                    onClick={() => setCurrentMode('convert')}
                    className={`flex-1 p-3 font-bold rounded-lg transition duration-300 ${currentMode === 'convert' ? 'bg-emerald-600 text-white shadow-md' : 'text-emerald-800 hover:bg-emerald-300'}`}
                    disabled={loading}
                >
                    4. تحويل النص الخام إلى SSML
                </button>
            </div>

            {currentMode === 'generate' ? (
                // --- Mode: Auto Generate Dialogue ---
                <div>
                    <label className="block text-lg font-bold text-gray-700 mb-2">موضوع الحوار التلقائي (3):</label>
                    <textarea
                        value={autoGenerateTopic}
                        onChange={(e) => setAutoGenerateTopic(e.target.value)}
                        className="w-full p-3 border border-gray-300 rounded-lg shadow-sm text-gray-800 disabled:bg-gray-100"
                        rows="2"
                        dir="rtl"
                        placeholder="مثال: نقاش بين Joe و Jane حول أفضل وجهات السفر لعام 2025."
                        disabled={loading} 
                    />
                    <button 
                        onClick={generateDialogueFromTopic} 
                        disabled={loading || !autoGenerateTopic.trim()}
                        className="btn w-full bg-emerald-600 text-white hover:bg-emerald-700 focus:ring-emerald-300 mt-4"
                    >
                        {loading ? 'جاري التوليد...' : '📝 توليد حوار خام'}
                    </button>
                    <p className="mt-4 text-sm text-gray-600 border-t pt-3">الناتج سيظهر في مربع النص الخام أدناه.</p>
                </div>
            ) : (
                // --- Mode: Convert Raw to SSML ---
                <div>
                    {/* Component 1: Raw Dialogue Input */}
                    <RawDialogueInputComponent 
                        value={rawDialogueInput}
                        onChange={(e) => setRawDialogueInput(e.target.value)}
                        disabled={loading}
                        speakerCount={speakerCount}
                    />
                    
                    {/* Component 2: SSML Instructions */}
                    <SSMLInstructionsComponent
                        value={ssmlInstructions}
                        onChange={(e) => setSSMLInstructions(e.target.value)}
                        disabled={loading}
                    />

                    <button 
                        onClick={convertToSSML} 
                        disabled={loading || !rawDialogueInput.trim()}
                        className="btn w-full bg-emerald-600 text-white hover:bg-emerald-700 focus:ring-emerald-300 mt-4"
                    >
                        {loading ? 'جاري التحويل...' : '⚙️ تحويل إلى SSML متقدم'}
                    </button>
                </div>
            )}
        </div>
    );


    return (
        <div className="p-4 md:p-8 font-[Tajawal] bg-gray-50 min-h-screen">
            <script src="[https://cdn.tailwindcss.com](https://cdn.tailwindcss.com)"></script>
            <style>{`
                @import url('[https://fonts.googleapis.com/css2?family=Tajawal:wght@400;700;800&display=swap](https://fonts.googleapis.com/css2?family=Tajawal:wght@400;700;800&display=swap)');
                body { font-family: 'Tajawal', sans-serif; }
                .card { transition: all 0.3s ease; }
                .btn { padding: 0.75rem 1.5rem; font-weight: 700; border-radius: 0.5rem; transition: background-color 0.3s, transform 0.1s; }
                .text-area-custom { min-height: 250px; }
            `}</style>
            
            <div className="max-w-6xl mx-auto">
                <header className="text-center mb-10">
                    <h1 className="text-4xl font-extrabold text-blue-700 mb-2">🎙️ مولد الحوارات المتعددة الأصوات (SSML)</h1>
                    <p className="text-lg text-gray-600 font-medium">نظام متكامل لتوليد المقالات، تحويل النصوص، والتحكم في النبرة الصوتية</p>
                </header>

                {/* Error/Success Message Display */}
                {errorMessage && (
                    <div className={`p-4 mb-6 rounded-xl font-medium ${errorMessage.isError ? 'bg-red-100 text-red-800 border border-red-300' : 'bg-green-100 text-green-800 border border-green-300'}`}>
                        {errorMessage.message}
                    </div>
                )}

                {/* Main Layout Grid */}
                <div className="grid grid-cols-1 lg:grid-cols-3 gap-8">
                    
                    {/* Column 1: Speaker Configuration */}
                    <div className="lg:col-span-1 space-y-8">
                        <SpeakerConfig />
                    </div>

                    {/* Column 2: LLM Input and Conversion */}
                    <div className="lg:col-span-2 space-y-8">
                        <LLMInputSection />
                    </div>
                </div>
                
                {/* Final Dialogue Area and Global Controls */}
                <div className="mt-10 grid grid-cols-1 lg:grid-cols-3 gap-8">
                    <div className="lg:col-span-2">
                        {/* Component 3: Final Dialogue (SSML) */}
                        <FinalDialogueComponent
                            value={dialogue}
                            onChange={(e) => setDialogue(e.target.value)}
                            disabled={loading}
                            speakerCount={speakerCount}
                        />
                    </div>
                    
                    {/* Column 3: Global Controls & Final Output */}
                    <div className="lg:col-span-1 space-y-8">
                        {/* Global Controls */}
                        <div className="card p-6 bg-yellow-50 border-4 border-yellow-300 shadow-xl rounded-xl">
                            {/* UPDATED TITLE */}
                            <h2 className="text-2xl font-extrabold text-yellow-800 mb-4">6. التحكم الكلي والتضخيم الصوتي</h2>
                            
                            {/* Volume Slider (Amplification) */}
                            <SliderLabel title="🔊 تضخيم/رفع مستوى الصوت الكلي" value={globalVolume} unit="dB" min={0} max={10} />
                            <input 
                                type="range" 
                                min="0" 
                                max="10" 
                                value={globalVolume} 
                                onChange={(e) => setGlobalVolume(parseInt(e.target.value))}
                                className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer range-lg focus:outline-none focus:ring-2 focus:ring-yellow-500 disabled:opacity-50"
                                disabled={loading}
                            />
                            <p className="text-sm text-gray-500 mt-1">يُطبق هذا التحكم تضخيماً بالديسيبل (dB) على كامل الملف الصوتي، مما يعادل وظيفة "Volume Booster" قبل التوليد. (القيمة القصوى: 10dB).</p>
                            
                            {/* Rate Slider */}
                            <SliderLabel title="⚡ سرعة القراءة الكلية" value={globalRate.toFixed(2)} unit="x" min={0.8} max={1.5} />
                            <input 
                                type="range" 
                                min="0.8" 
                                max="1.5" 
                                step="0.05"
                                value={globalRate} 
                                onChange={(e) => setGlobalRate(parseFloat(e.target.value))}
                                className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer range-lg focus:outline-none focus:ring-2 focus:ring-yellow-500 disabled:opacity-50"
                                disabled={loading}
                            />
                            
                            <button 
                                onClick={generateMultiSpeakerAudio} 
                                disabled={loading || dialogue.trim().length === 0}
                                className="btn w-full bg-indigo-600 text-white hover:bg-indigo-700 focus:ring-indigo-300 mt-6 disabled:bg-gray-400"
                            >
                                {loading ? 'جاري توليد الصوت...' : '▶️ توليد وتشغيل الحوار الصوتي'}
                            </button>
                            
                            {/* Audio Player */}
                            <div className="mt-4 p-3 bg-white rounded-lg border">
                                {audioUrl ? (
                                    <audio ref={audioRef} controls className="w-full"></audio>
                                ) : (
                                    <p className="text-center text-gray-500 italic text-sm">سيظهر مشغل الصوت هنا.</p>
                                )}
                            </div>
                        </div>
                    </div>
                </div>

            </div>
        </div>
    );
}

export default App;
